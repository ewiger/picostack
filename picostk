#!/usr/bin/env python
'''***picostk*** is a command-line interface for **picostack** - a complete
minimalistic KVM virtualization manager suitable for single linux-based host
system.

Copyright (c) 2014 Yauhen Yakimovich

The MIT License (MIT). Read a copy of LICENSE distributed with this code.

See README and project page at https://github.com/ewiger/picostack
'''
import os
import sys
import argparse
import logging
import textwrap
from functools import partial
from daemoncxt.runner import DaemonRunner

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "picostack.settings")
sys.path.append(os.path.dirname(__file__))

from picostack.deamon_app import (get_picostack_app, getBasicLogger)
from picostack.vms.models import (VmImage, VmInstance, Flavour)
from picostack import __version__ as PICOSTACK_VERSION
from picostack.errors import PicoStackError


USER_HOME_DIR = os.path.expanduser('~/')
VM_MANAGER = 'KVM'
APP_NAME = 'picostk'
CONFIG_NAME = APP_NAME + '.conf'
CONFIG_DIR = os.path.join(USER_HOME_DIR, '.picostack')
DEBUG = True
APP_DIR = os.path.dirname(os.path.abspath(__file__))
logger = getBasicLogger(APP_NAME, logging.DEBUG)
is_interactive = False
LINE_WIDTH = 80
CONFIG_VARS = {
    'config_name': CONFIG_NAME,
    'manager_name': VM_MANAGER,
    'default_statepath': CONFIG_DIR,
}


def format_text(text):
    lines = text.split('\n')
    lines = [line.lstrip() for line in lines]
    if len(lines[0].strip()) == 0:
        lines.pop(0)
    return '\n'.join(lines)
    #lines = textwrap.wrap(textwrap.dedent(text), width=LINE_WIDTH,
    #                      break_on_hyphens=False, break_long_words=False)
    #return '\n'.join(lines)


class MissingCliArgs(PicoStackError):
    '''Error of parsing command-line arguments.'''

class PicoStackIOError(PicoStackError):
    '''Similar to IOError but relates to PicoStack logic.'''

class PicoStack(object):

    def __init__(self, options):
        self.options = options

    def list_images(self):
        if len(VmImage.objects.all()) == 0:
            print 'There are no VM images found. Maybe you should add some?'
            exit()
        print 'Listing all VM images..'
        for index, vm_image in enumerate(VmImage.objects.all()):
            print '-' * LINE_WIDTH
            print format_text('''
                VM image #%(index)d

                name: %(name)s
                ''' % {
                'index': index,
                'name': vm_image.name,
            })

    def list_instances(self):
        if len(VmInstance.objects.all()) == 0:
            print 'There are no VM instances found.'
            exit()
        print 'Listing all VM instances..'
        for index, vm_instance in enumerate(VmInstance.objects.all()):
            print '-' * LINE_WIDTH
            print format_text('''
                VM instance #%(index)d

                name: %(name)s
                status: %(status)s
                ''' % {
                'index': index,
                'name': vm_instance.name,
                'status': vm_instance.status,
            })

    def init_config(self):
        '''
        Initialize configuration in <CONFIG_DIR>/config file. Create
        default settings and other expected folders and files.
        '''
        if os.path.exists(CONFIG_DIR):
            raise PicoStackIOError('Abort. Config location already exists: '
                                   '%s' % CONFIG_DIR)
        os.mkdir(CONFIG_DIR)
        config_path = os.path.join(CONFIG_DIR, CONFIG_NAME)
        print 'Putting default configuration into %s' % config_path
        # Get app with config defaults.
        picostack_app = get_picostack_app(
            app_name=APP_NAME,
            config_vars=CONFIG_VARS,
            config_dir=CONFIG_DIR,
            is_interactive=True,
            is_debug=DEBUG,
            only_defaults=True,
        )
        # Write defaults.
        with open(config_path, 'w+') as config_file:
            picostack_app.config.write(config_file)
        # Make missing folders. Can be later symlinked to a different location.
        missing_folders = [
            picostack_app.config.get('vm_manager', 'vm_image_path'),
            picostack_app.config.get('vm_manager', 'vm_disk_path'),
        ]
        for missing_folder in missing_folders:
            print 'Creating missing folder: %s' % missing_folder
            os.mkdir(missing_folder)


    @staticmethod
    def run_as_daemon(args, subparser):
        # Has user defined an action.
        if not args.action:
            subparser.print_help()
            return
        # Get app that can do {start, stop, restart}.
        picostack_app = get_picostack_app(
            app_name=APP_NAME,
            config_vars=CONFIG_VARS,
            config_dir=CONFIG_DIR,
            is_interactive=is_interactive,
            is_debug=DEBUG,
        )
        if args.action == 'start' and is_interactive:
            picostack_app.run()

            return
        if args.action == 'stop' or args.action == 'restart':
            # Stop all VMs.
            pass
        # Note: picostack daemon app will find pid and kill the process or
        # start a new one. We just need to pass the action.
        app_argv = [sys.argv[0], args.action]
        daemon_runner = DaemonRunner(picostack_app, app_argv)
        daemon_runner.do_action()

    @staticmethod
    def process_image_cmds(args, subparser):
        instance = PicoStack(args)
        if args.list:
            instance.list_images()
        else:
            subparser.print_help()

    @staticmethod
    def process_instance_cmds(args, subparser):
        instance = PicoStack(args)
        if args.list:
            instance.list_instances()
        elif args.build_from_image:
            # vm name
            if not args.vm_name:
                raise MissingCliArgs('Missing vm_name in --vm-name.')
            vm_name = args.vm_name
            # image name
            if not args.build_from_image:
                raise MissingCliArgs('Missing image name in '
                                     '--build-from-image.')
            image_name = args.build_from_image
            # flavour name
            if not args.flavour:
                raise MissingCliArgs('Missing flavour name in --flavour.')
            flavour_name = args.flavour
            # Do actual work. Exceptions are handled by calling functions.
            sys.stdout.write('Trying to start building a new VM instance "%s"'
                             ' from image "%s"..' % (vm_name, image_name))
            VmInstance.build_vm(vm_name, image_name, flavour_name)
            sys.stdout.write('OK, new VM instance is in cloning now.')

        else:
            subparser.print_help()

    @staticmethod
    def process_init_cmds(args, subparser):
        instance = PicoStack(args)
        if args.target == 'config':
            instance.init_config()
        else:
            subparser.print_help()


class ArgumentParser(argparse.ArgumentParser):

    def error(self, message):
        self.print_help(sys.stderr)
        self.exit(2, '%s: error: %s\n' % (self.prog, message))


if __name__ == '__main__':
    parser = ArgumentParser(description='Command-line interface for picostack '
                            + ' - a minimalistic KVM manager.')
    parser.add_argument('-i', '--interactive', action='store_true',
                        default=False)
    parser.add_argument("-v", "--verbosity", action="count",
                        help='Increase logging verbosity (-v WARN, -vv INFO, '
                        '-vvv DEBUG)')
    parser.add_argument('--version', action='version',
                        version='%(prog)s ' + PICOSTACK_VERSION)


    # TODO: add more sophisticated logging as in
    # http://stackoverflow.com/questions/17275334/what-is-a-correct-way-to-filter-different-loggers-using-python-logging
    # and logging.config.dictConfig
    subparsers = parser.add_subparsers()

    # initialization routines
    init_parser = subparsers.add_parser('init')
    init_parser.add_argument('target', choices=['config', 'UbuntuJeOS'])
    init_parser.set_defaults(handler=partial(
        PicoStack.process_init_cmds, subparser=init_parser))

    # daemon
    daemon_parser = subparsers.add_parser('daemon')
    # TODO: action must be a choice
    daemon_parser.add_argument('action', choices=['start', 'stop', 'restart'])
    daemon_parser.set_defaults(handler=partial(
        PicoStack.run_as_daemon, subparser=daemon_parser))

    # images
    images_parser = subparsers.add_parser('images')
    images_parser.set_defaults(handler=partial(
        PicoStack.process_image_cmds, subparser=images_parser))
    images_parser.add_argument('--list', action='store_true', default=False,
                               help='List images and their states')

    # instances
    instances_parser = subparsers.add_parser('instances')
    instances_parser.set_defaults(handler=partial(
        PicoStack.process_instance_cmds, subparser=instances_parser))

    instances_parser.add_argument('--vm-name',
                                  help='Unique name of VM instance.')

    instances_parser.add_argument('--flavour',
                                  help='Unique name of existing VM flavour.')

    instances_parser.add_argument('--list', action='store_true', default=False,
                                  help='List instances and their states.')
    instances_parser.add_argument('--build-from-image',
                                  help='Build a new VM from image.')
    instances_parser.add_argument('--destroy',
                                  help='Completely remove VM and its files.')
    instances_parser.add_argument('--start', dest='start_vm',
                                  help='Start VM instance.')
    instances_parser.add_argument('--stop',
                                  help='Stop VM instance.')

    # Parse arguments.
    args = parser.parse_args()
    # On error this will print help and cause exit with explanation message.
    is_interactive = args.interactive
    try:
        if args.handler:
            args.handler(args)
        else:
            parser.print_help()

    except PicoStackError as pico_error:
        print 'Failed.'
        if type(pico_error) is MissingCliArgs:
            print 'Missing one of the required command-line arguments.'
        print 'Error message: "%s"' % str(pico_error)
